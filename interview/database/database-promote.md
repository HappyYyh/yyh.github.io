---
title: 数据库提升
permalink: /interview/database/database-promote
key: database-promote
---

## 事务    

### 【数据库事务ACID四大特性】

1. **原子性（Atomicity）**
   　　原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。

   

2. **一致性（Consistency）**
   　　一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。
   　　拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。

   

3. **隔离性（Isolation）**
   　　隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。
   　　即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。

   

4. **持久性（Durability）**
   　　持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。
   　　例如我们在使用JDBC操作数据库时，在提交事务方法后，提示用户事务操作完成，当我们程序执行完成直到看到提示后，就可以认定事务以及正确提交，
   即使这时候数据库出现了问题，也必须要将我们的事务完全执行完成，否则就会造成我们看到提示事务处理完毕，但是数据库因为故障而没有执行事务的重大错误。


### 【事务的传播行为】

1. **PROPAGATION_REQUIRED：**

   如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置。

2. **PROPAGATION_SUPPORTS：**

   支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。

3. **PROPAGATION_MANDATORY：**

   支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。

4. **PROPAGATION_REQUIRES_NEW：**

   创建新事务，无论当前存不存在事务，都创建新事务。

5. **PROPAGATION_NOT_SUPPORTED：**

   以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。

6. **PROPAGATION_NEVER：**

   以非事务方式执行，如果当前存在事务，则抛出异常。

7. **PROPAGATION_NESTED：**

   如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。



### 【怎么理解原子性】  

> 原子性是指一个事物的操作是不可分割的，要么都发生，要么都不发生。

举例：

张三到银行给李四转账1000元，张三卡里原来有2000元，李四卡里原来也有两千元，那么转账的步骤应该如下：

张三扣除1000，剩余1000 --》银行收到张三的扣款--》李四增加1000元，变成3000元

如果张三的钱扣完，银行系统瘫痪了，怎么办呢？

张三的1000块钱会被会没呢，当然不会。这时候你的钱会退回来。也就是说银行的转账业务要么成功张三（1000元）李四（3000元），要么不发生张三（2000元）李四（2000元）。



### 【MySQL如何实现事务中持久性】  

> 持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。

为了实现事务的原子性和持久性，mysql引入了**undo**和**redo**日志（即**undo log**和**redo log**）

一、undo

undo日志记录的是**修改前的值**，当事务提交之后，undo不会被马上删除，而是放入待删除队列，由purge线程来判断是否删除和处理。

二、redo

redo日志记录的是**修改后最新的数据**和冗余的undo日志，另外，**未提交的事务**和**回滚了的事务**也会计入redo日志。mysql恢复策略是：

1. 恢复时，先根据**redo**重做所有事务（包括未提交和回滚了的）
2. 再根据**undo**回滚未提交的事务。

利用这两个就能够实现事务的持久性



## 隔离级别   

### 【脏读/虚读(幻读)/重复读什么意思？发生在哪 ？】 

- **脏读**：

  > 一个事务读取了另一个事务改写但还未提交的数据，如果这些数据被回滚，则读到的数据是无效的。

  比如：

  ~~~sql
  事务T1修改了一行数据，但是还没有提交，这时候事务T2读取了被事务T1修改后的数据，之后事务T1因为某种原因Rollback了，那么事务T2读取的数据就是脏的
  ~~~

  

- **不可重复读**：

  > 在同一事务中，多次读取同一数据返回的结果有所不同，读到了之前的数据后又读到了其他事务已经提交的更新的数据。

  比如：

  ~~~sql
  //1、在事务1中，JoonWhee读取了自己的工资为1000，但是此时事务1的操作还并没有完成 ，后面还有1次相同的读取操作。
  select salary from employee where employeeName ="JoonWhee";  
  //2、在事务2中，这时财务人员修改了JoonWhee的工资为2000，并提交了事务。
  update employee set salary = 2000 where employeeName = "JoonWhee";    
  //3、在事务1中，JoonWhee再次读取自己的工资时，工资变为了2000 。
  select salary from employee where employeeName ="JoonWhee";
  //在一个事务中前后两次读取的结果并不致，导致了不可重复读。
  ~~~

  

- **幻读（虚读）**：

  > 一个事务读取了几行记录后，另一个事务插入（insert）一些记录，再后来的查询中，第一个事务就会发现有些原来没有的记录。

  比如

  ~~~sql
  //1、事务1查询id=1的用户是否存在
  select * from User where id = 1;  
  //2、在事务1查询完以后，事务2插入了一条id为1的记录
  insert into `User`(`id`, `name`) values (1, 'Joonwhee');  
  //3、由于事务1查询到id为1的用户不存在，因此插入1条id为1的数据。
  insert into ` User`(`id`, `name`) values (1, 'Chillax');  
  //4、但是由于事务2已经插入主键为1的记录了，因此此时会报主键冲突，对于事务1 的业务来说是执行失败的，这里事务1 就是发生了幻读
  ~~~

### 【不可重复读和幻读的区别】

**幻读**

> 事务在插入已经检查过不存在的记录时，惊奇的发现这些数据已经存在了，之前的检测获取到的数据如同鬼影一般。



不可重复读**

> 同样的条件，你读取过的数据，再次读取出来发现值不一样了。





### 【MySQL的事务隔离级别，分别解决什么问题】  

MySQL使用**可重复读(Repeatable reads)**作为默认的事务隔离级别

|           事务隔离级别            | 脏读 | 不可重复读 | 幻读 |
| :-------------------------------: | :--: | :--------: | :--: |
|    未提交读(Read uncommitted)     |  是  |     是     |  是  |
| 提交读/不可重复读(Read committed) |  否  |     是     |  是  |
|    可重复读(Repeatable reads)     |  否  |     否     |  是  |
|     可串/序行化(Serializable)     |  否  |     否     |  否  |

- **未提交读(Read uncommitted)**

  > 未提交读(READ UNCOMMITTED)是最低的隔离级别。通过名字我们就可以知道，在这种事务隔离级别下，一个事务可以读到另外一个事务未提交的数据

  **未提交读的数据库锁情况（实现原理）**

  事务在读数据的时候并未对数据加锁。事务在修改数据的时候只对数据增加**行级共享锁**

  **未提交读会导致脏读**

  

- **提交读/不可重复读(Read committed)**

  > 提交读(READ COMMITTED)也可以翻译成读已提交，通过名字也可以分析出，在一个事务修改数据过程中，如果事务还没提交，其他事务不能读该数据。

  **提交读的数据库锁情况（实现原理）**

  事务对当前被读取的数据加**行级共享锁（当读到时才加锁）**，**一旦读完该行，立即释放该行级共享锁；**

  事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加**行级排他锁**，直到**事务结束才释放**。

  **提交读可以解决脏读的现象，不能解决不可重复读的读现象**

  

- **可重复读(Repeatable reads)**

  > 可重复读(REPEATABLE READS),由于提交读隔离级别会产生不可重复读的读现象。所以，比提交读更高一个级别的隔离级别就可以解决不可重复读的问题。这种隔离级别就叫可重复读。

  **可重复读的数据库锁情况**

  事务在读取某数据的瞬间（就是开始读取的瞬间），必须先对其加**行级共享锁**，直到**事务结束才释放；**

  事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加**行级排他锁**，直到**事务结束才释放。**

  **能够解决不可重复读的读现象,可以解决脏读的现象**

  

- **可串/序行化(Serializable)**

  > 可序列化(Serializable)是最高的隔离级别，前面提到的所有的隔离级别都无法解决的幻读，在可序列化的隔离级别中可以解决。

  **可串列化的数据库锁情况（实现原理）**

  事务在读取数据时，必须先对其加**表级共享锁** ，直到**事务结束才释放；**

  事务在更新数据时，必须先对其加**表级排他锁** ，直到**事务结束才释放。**

  然可序列化解决了脏读、不可重复读、幻读等读现象。但是序列化事务会产生以下效果：

  ​     1.无法读取其它事务已修改但未提交的记录。

  ​     2.在当前事务完成之前，其它事务不能修改目前事务已读取的记录。

  ​     3.在当前事务完成之前，其它事务所插入的新记录，其索引键值不能在当前事务的任何语句所读取的索引键范围中。



### 【如何用可重复读的隔离级别避免幻读】  

1、在快照读读情况下，MySQL通过MVCC来避免幻读。

2、在当前读读情况下，MySQL通过next-key（行锁+GAP锁也就是间隙锁）来避免幻。



### 【可重复读底层实现】  

事务ID是递增的。

使用MVCC（多版本并发控制）。InnoDB为每行记录添加了一个事务ID，每当修改数据时，将当事务ID写入。
在读取事务开始时，系统会给事务一个当前版本号(事务ID)，事务会读取版本号<=当前版本号的数据，这时就算另一个事务插入一个数据，并立马提交，新插入这条数据的版本号会比读取事务的版本号高，因此读取事务读的数据还是不会变。



## 执行引擎

### 【你了解那些数据库引擎，说说它们的异同优劣】

- **MyISAM：**

  默认的MySQL插件式存储引擎，它是在Web、数据仓储和其他应用环境下最常使用的存储引擎之一。注意，通过更改STORAGE_ENGINE配置变量，能够方便地更改MySQL服务器的默认存储引擎。

- **InnoDB：**

  用于事务处理应用程序，具有众多特性，包括ACID事务支持。**(提供行级锁)**

- **BDB：**

  可替代InnoDB的事务引擎，支持COMMIT、ROLLBACK和其他事务特性。

- **Memory：**

  将所有数据保存在RAM中，在需要快速查找引用和其他类似数据的环境下，可提供极快的访问。

- **Merge：**

  允许MySQL DBA或开发人员将一系列等同的MyISAM表以逻辑方式组合在一起，并作为1个对象引用它们。对于诸如数据仓储等VLDB环境十分适合。

- **Archive：**

  为大量很少引用的历史、归档、或安全审计信息的存储和检索提供了完美的解决方案。

- **Federated：**

  能够将多个分离的MySQL服务器链接起来，从多个物理服务器创建一个逻辑[数据库](http://lib.csdn.net/base/14)。十分适合于分布式环境或数据集市环境。

- **Cluster/NDB：**

  MySQL的簇式数据库引擎，尤其适合于具有高性能查找要求的应用程序，这类查找需求还要求具有最高的正常工作时间和可用性。

- **Other：**

  其他存储引擎包括CSV（引用由逗号隔开的用作数据库表的文件），Blackhole（用于临时禁止对数据库的应用程序输入），以及Example引擎（可为快速创建定制的插件式存储引擎提供帮助）。

  

### 【MySQL常见的执行引擎有哪些】

常见的有四种：Memory、InnoDB、MyISAM、Archive



### 【MySQL数据库默认存储引擎，有什么优点】

**InnoDB 引擎(MySQL5.5以后默认使用)**

优点如下：

- 灾难恢复性好
- 支持事务
- 使用行级锁
- 支持外键关联
- 支持热备份
- 对于InnoDB引擎中的表，其数据的物理组织形式是簇表（Cluster Table），主键索引和数据是在一起的，数据按主键的顺序物理分布
- 实现了缓冲管理，不仅能缓冲索引也能缓冲数据，并且会自动创建散列索引以加快数据的获取
- 支持热备份



### 【InnoDB和MYISAM的区别】

1. **InnoDB支持事务，MyISAM不支持**

   对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务； 

   

2. **InnoDB支持外键，而MyISAM不支持**

   对一个包含外键的InnoDB表转为MYISAM会失败； 

   

3. **InnoDB是聚集索引，MyISAM是非聚集索引**

   InnoDB数据文件是和（主键）索引绑在一起的（表数据文件本身就是按B+Tree组织的一个索引结构），必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。

   MyISAM索引和数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。

   

4. **InnoDB不保存表的具体行数，MyISAM用一个变量保存了整个表的行数**

   InnoDB执行select count(\*) from table时需要全表扫描。

   而MyISAM执行上述语句时只需要读出该变量即可，速度很快（注意不能加有任何WHERE条件）

   

5. **Innodb不支持全文索引，而MyISAM支持全文索引**

   在涉及全文索引领域的查询效率上MyISAM速度更快高；PS：5.7以后的InnoDB支持全文索引了

   

6. **MyISAM表格可以被压缩后进行查询操作**

   

7. **InnoDB支持表、行(默认)级锁，而MyISAM支持表级锁**

   

8. **InnoDB表必须有主键而MyISAM可以没有**

   InnoDB用户没有指定的话会自己找或生产一个主键

   

9. **Innodb存储文件有frm、ibd，而MyISAM是frm、MYD、MYI**

   Innodb：frm是表定义文件，ibd是数据文件

   Myisam：frm是表定义文件，myd是数据文件，myi是索引文件



### 【InnoDB多版本并发控制】  

> MVCC：Multi-Version Concurrency Control 多版本并发控制。
>
> 什么是多版本并发控制呢 ？其实就是在每一行记录的后面增加两个隐藏列，记录**创建版本号**和**删除版本号**
>
> MVCC工作在 ：在REPEATABLE READ和READ COMMITED 两种事务下面
>
> MVCC并不是MySql独有的，Oracle，PostgreSQL等都在使用。
>
> MVCC并没有简单地使用行锁，而是使用“行级别锁”（row-level locking）。

MVCC的**基本原理**：

MVCC的实现，通过保存数据在某个时间点的快照来实现的。这意味着一个事务无论运行多长时间，在同一个事务里能够看到数据一致的视图。根据事务开始的时间不同，同时也意味着在同一个时刻不同事务看到的相同表里的数据可能是不同的。

MVCC的**基本特征**：

- 每行数据都存在一个版本，每次数据更新时都更新该版本。
- 修改时Copy出当前版本随意修改，各个事务之间无干扰。
- 保存时比较版本号，如果成功（commit），则覆盖原记录；失败则放弃copy（rollback）

InnoDB存储引擎MVCC的**实现策略**：

在每一行数据中额外保存两个隐藏的列：当前行创建时的版本号和删除时的版本号（可能为空）。这里的版本号并不是实际的时间值，而是系统版本号。每开始 个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询每行记录的版本号进行比较。

每个事务又有自己的版本号，这样事务内执行CRUD操作时，就通过版本号的比较来达到数据版本控制的目的。





## 索引  

索引的几种类型？  
索引的存储结构？   
索引的结构   
查询主键/非主键索引的实现方式  
索引原理，索引失效  
数据库索引结构，为什么快 ，索引的实现原理？  
使用B+树的好处？  
B树和B+树的区别？  
HASH与B+树对比？哪种场景下应用更合适？  
索引值改变了，树的结构如何改变？  
MySQL的联合索引  
主键索引与二级索引的区别   
主键索引存储什么数据   
为什么主键用auto_increment   
如何生成唯一主键 A:UUID   
UUID的缺点   
建立索引要注意什么。  
索引的原则  
聚簇索引和非聚簇索引的区别  
数据库索引原理，组合索引怎么使用？最左匹配的原理   
各种索引存储结构的应用场景。  
联合索引，如何创建联合索引，联合索引的数据结构    
mysql索引的数据结构，为什么用B+树不用B树  
聚类索引和非聚类索引的区别，聚类索引和非聚类索引的区别  
联合索引的最左匹配原则   
身份证如何有效建立索引  
uuid怎么做的，了解哪些UUID生成策略(雪花)   
数据库的索引有哪几种？  
为什么要用B+树来做索引？  
组合索引和几个单个的索引有什么区别？  
B树和B+树的区别？  
jhash和B+树的区别？分别应用于什么场景？哪个比较好？   
索引是什么概念有什么作用？  
数据库的最左匹配原则是啥？怎么用？  

## 存储过程

## 封锁

数据库有哪些锁  
数据库乐观锁和悲观锁   
表锁和行锁的区别  
哪些场景需要加表锁  
插入一条数据需要加什么锁  
间隙锁   
聚集锁非聚集锁  
锁协议    
mysql查询加行锁怎么写   
并发问题  