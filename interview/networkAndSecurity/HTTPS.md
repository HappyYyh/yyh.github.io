---
title: HTTPS
permalink: /interview/networkAndSecurity/HTTPS
key: networkAndSecurity-HTTPS
---

### 【解释HTTPS】

**概念：**

> HTTPS（Hyper Text Transfer Protocol over SecureSocket Layer） 超文本传输安全协议;是HTTP协议和SSL/TLS协议的组合。主要通过数字证书、加密算法、非对称密钥等技术完成互联网数据传输加密，实现互联网传输安全保护。

**由来：**

HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。

**设计目标：**

1. **数据保密性**：保证数据内容在传输的过程中不会被第三方查看。
2. **数据完整性**：及时发现被第三方篡改的传输内容。
3. **身份校验安全性**：保证数据到达用户期望的目的地。



### 【HTTP和HTTPS的区别】 

HTTPS和HTTP的区别主要如下：

1. HTTPS协议需要到CA（Certificate Authority，数字证书认证机构）申请证书，一般免费证书较少，因而需要一定费用。
2. HTTP是超文本传输协议，信息是**明文传输**，HTTPS则是具有安全性的**ssl加密传输协议**。
3. HTTP 页面响应速度比 HTTPS 快，主要是因为 HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包，而 HTTPS除了 TCP 的三个包，还要加上 SSL握手需要的 9 个包，所以一共是 12 个包。
4. HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
5. HTTP的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比HTTP协议安全。



### 【HTTPS安全的概念是怎样理解的】

**HTTP不安全：** 

HTTP协议属于明文传输协议，交互过程以及数据传输都没有进行加密，通信双方也没有进行任何认证，通信过程非常容易遭遇劫持、监听、篡改，严重情况下，会造成恶意的流量劫持等问题，甚至造成个人隐私泄露（比如银行卡卡号和密码泄露）等严重的安全问题。

要解决HTTP带来的问题，就要引入**加密以及身份验证机制**。

如果Server（以后简称服务器）给Client（以后简称 客户端）的消息是密文的，只有服务器和客户端才能读懂，就可以保证数据的保密性。同时，在交换数据之前，验证一下对方的合法身份，就可以保证通信双方的安全。

**HTTPS安全：**

HTTPS在TCP层与HTTP层之间加入了SSL/TLS来为上层的安全保驾护航，主要用到对称加密、非对称加密、证书，等技术进行客户端与服务器的数据加密传输，最终达到保证整个通信的安全性。（后文讲关于加密和SSL等）



### 【HTTPS建立连接的流程】 

HTTPS 默认工作在 TCP 协议443端口，它的工作流程一般如以下方式：

1. TCP 三次同步握手
2. 客户端验证服务器数字证书
3. DH 算法协商对称加密算法的密钥、hash 算法的密钥
4. SSL 安全加密隧道协商完成
5. 网页以加密的方式传输，用协商的对称加密算法和密钥加密，保证数据机密性；用协商的hash算法进行数据完整性保护，保证数据不被篡改。



### 【HTTPS加密流程】

摘自[菜鸟教程](https://www.runoob.com/w3cnote/http-vs-https.html)

我们都知道 HTTPS 能够加密信息，以免敏感信息被第三方获取，所以很多银行网站或电子邮箱等等安全级别较高的服务都会采用 HTTPS 协议。

![img](https://www.runoob.com/wp-content/uploads/2018/09/https-intro.png)

1. **客户端发起 HTTPS 请求**

   这个没什么好说的，就是用户在浏览器里输入一个 https 网址，然后连接到 server 的 443 端口。

2. **服务端的配置**

   采用 HTTPS 协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请，区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面(startssl 就是个不错的选择，有 1 年的免费服务)。

   这套证书其实就是一对公钥和私钥，如果对公钥和私钥不太理解，可以想象成一把钥匙和一个锁头，只是全世界只有你一个人有这把钥匙，你可以把锁头给别人，别人可以用这个锁把重要的东西锁起来，然后发给你，因为只有你一个人有这把钥匙，所以只有你才能看到被这把锁锁起来的东西。

3. **传送证书**

   这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等等。

4. **客户端解析证书**

   这部分工作是有客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。

   如果证书没有问题，那么就生成一个随机值，然后用证书对该随机值进行加密，就好像上面说的，把随机值用锁头锁起来，这样除非有钥匙，不然看不到被锁住的内容。

5. **传送加密信息**

   这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。

6. **服务端解密信息**

   服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行对称加密，所谓对称加密就是，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。

7. **传输加密后的信息**

   这部分信息是服务段用私钥加密后的信息，可以在客户端被还原。

8. **客户端解密信息**

   客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容，整个过程第三方即使监听到了数据，也束手无策。



### 【HTTPS的工作原理】

HTTPS在传输数据之前需要客户端（浏览器）与服务端（网站）之间进行一次**握手**，在握手过程中将确立双方加密传输数据的密码信息。

**握手过程**的简单描述如下：

1. 浏览器将自己支持的一套加密规则发送给网站。

2. 网站从中选出一组加密算法与HASH算法，并将自己的身份信息以证书的形式发回给浏览器。证书里面包含了网站地址，加密公钥，以及证书的颁发机构等信息。

3. 获得网站证书之后浏览器要做以下工作：

   - 验证证书的合法性（颁发证书的机构是否合法，证书中包含的网站地址是否与正在访问的地址一致等），如果证书受信任，则浏览器栏里面会显示一个小锁头，否则会给出证书不受信的提示。

   - 如果证书受信任，或者是用户接受了不受信的证书，浏览器会生成一串随机数的密码，并用证书中提供的公钥加密。

   - 使用约定好的HASH计算握手消息，并使用生成的随机数对消息进行加密，最后将之前生成的所有信息发送给网站。

4. 网站接收浏览器发来的数据之后要做以下的操作：

   - 使用自己的私钥将信息解密取出密码，使用密码解密浏览器发来的握手消息，并验证HASH是否与浏览器发来的一致。

   - 使用密码加密一段握手消息，发送给浏览器。

5. 浏览器解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束，之后所有的通信数据将由之前浏览器生成的随机密码并利用对称加密算法进行加密。


这里浏览器与网站互相发送加密的握手消息并验证，目的是为了保证双方都获得了一致的密码，并且可以正常的加密解密数据，为后续真正数据的传输做一次**测试**。

**使用的加密算法：**

其中非对称加密算法用于在握手过程中加密生成的密码，对称加密算法用于对真正传输的数据进行加密，而HASH算法用于验证数据的完整性。

由于浏览器生成的密码是整个数据加密的关键，因此在传输的时候使用了非对称加密算法对其加密。非对称加密算法会生成公钥和私钥，公钥只能用于加密数据，因此可以随意传输，而网站的私钥用于对数据进行解密，所以网站都会非常小心的保管自己的私钥，防止泄漏。

TLS握手过程中如果有任何错误，都会使加密连接断开，从而阻止了隐私信息的传输。



### 【数据传输过程用的什么加密】  

数据在互联网中并不会使用单一加密技术，往往都是各类技术**混合使用**，互补优缺点使数据的传输更加安全。



### 【对称加密和非对称加密的区别和应用场景】

**概念：**

- **介绍：**

  加密算法分对称加密和非对称加密，其中对称加密算法的加密与解密密钥相同，非对称加密算法的加密密钥与解密密钥不同，此外，还有一类 不需要密钥的散列算法。

- **对称加密：**

  对称加密算法是应用较早的加密算法，又称为共享密钥加密算法。在对称加密算法中，使用的密钥只有一个，发送和接收双方都使用这个密钥对数据进行加密和解密。这就要求加密和解密方事先都必须知道加密的密钥。

  对称加密通常使用的是相对较小的密钥，一般小于256 bit。因为密钥越大，加密越强，但加密与解密的过程越慢。

- **非对称加密：**

  非对称加密算法，又称为公开密钥加密算法。它需要两个密钥，一个称为公开密钥 (`public key`)，即公钥，另一个称 私有密钥 (`private key`)，即私钥。

  非对称密钥加密的**使用过程**：
  1. A要向B发送信息，A和B都要产生一对用于加密和解密的公钥和私钥。
  2. A的私钥保密，A的公钥告诉B；B的私钥保密，B的公钥告诉A。
  3. A要给B发送信息时，A用B的公钥加密信息，因为A知道B的公钥。
  4. A将这个消息发给B（已经用B的公钥加密消息）。
  5. B收到这个消息后，B用自己的私钥解密A的消息，其他所有收到这个报文的人都无法解密，因为只有B才有B的私钥。
  6. 反过来，B向A发送消息也是一样。

**区别：**

- 对称加密加密与解密使用的是同样的密钥，所以速度快，但由于需要将密钥在网络传输，所以安全性不高。
- 非对称加密使用了一对密钥，公钥与私钥，所以安全性高，但加密与解密速度慢。
- 解决的办法是将**对称加密的密钥使用非对称加密的公钥进行加密，然后发送出去，接收方使用私钥进行解密得到对称加密的密钥，然后双方可以使用对称加密来进行沟通**。



### 【常见的签名加密算法】

**分类：**

> **对称加密** `DES`、`3DES`、`AES` 
>
> **非对称算法** 主要有 `RSA`、`DSA` 等，
>
> **散列算法** 主要有 `SHA-1`、`MD5` 等。

**[具体实现：](https://juejin.im/post/5b48b0d7e51d4519962ea383#heading-10)**

- **MD5算法**

  `MD5` 用的是 **哈希函数**，它的典型应用是对一段信息产生 **信息摘要**，以 **防止被篡改**。严格来说，`MD5` 不是一种 **加密算法** 而是 **摘要算法**。无论是多长的输入，`MD5` 都会输出长度为 `128bits` 的一个串 (通常用 `16` **进制** 表示为 `32` 个字符)。

  ~~~java
  public static final byte[] computeMD5(byte[] content) {
      try {
          MessageDigest md5 = MessageDigest.getInstance("MD5");
          return md5.digest(content);
      } catch (NoSuchAlgorithmException e) {
          throw new RuntimeException(e);
      }
  }
  ~~~

- **SHA-1算法**

  `SHA1` 是和 `MD5` 一样流行的 **消息摘要算法**，然而 `SHA1` 比 `MD5` 的 **安全性更强**。对于长度小于 `2 ^ 64` 位的消息，`SHA1` 会产生一个 `160` 位的 **消息摘要**。基于 `MD5`、`SHA1` 的信息摘要特性以及 **不可逆** (一般而言)，可以被应用在检查 **文件完整性** 以及 **数字签名** 等场景。

  ~~~java
  public static byte[] computeSHA1(byte[] content) {
      try {
          MessageDigest sha1 = MessageDigest.getInstance("SHA1");
          return sha1.digest(content);
      } catch (NoSuchAlgorithmException e) {
          throw new RuntimeException(e);
      }
  }
  ~~~

- **HMAC算法**

  `HMAC` 是密钥相关的 **哈希运算消息认证码**（Hash-based Message Authentication Code），`HMAC` 运算利用 **哈希算法** (`MD5`、`SHA1` 等)，以 **一个密钥** 和 **一个消息** 为输入，生成一个 **消息摘要** 作为 **输出**。

  `HMAC` **发送方** 和 **接收方** 都有的 `key` 进行计算，而没有这把 `key` 的第三方，则是 **无法计算** 出正确的 **散列值**的，这样就可以 **防止数据被篡改**。

- **AES/DES/3DES算法**

  `AES`、`DES`、`3DES` 都是 **对称** 的 **块加密算法**，**加解密** 的过程是 **可逆的**。常用的有 `AES128`、`AES192`、`AES256` (默认安装的 `JDK` 尚不支持 `AES256`，需要安装对应的 `jce` 补丁进行升级 `jce1.7`，`jce1.8`)。

- **RSA算法**

  `RSA` 加密算法是目前最有影响力的 **公钥加密算法**，并且被普遍认为是目前 **最优秀的公钥方案** 之一。`RSA` 是第一个能同时用于 **加密** 和 **数字签名** 的算法，它能够 **抵抗** 到目前为止已知的 **所有密码攻击**，已被 `ISO` 推荐为公钥数据加密标准。

  > `RSA` **加密算法** 基于一个十分简单的数论事实：将两个大 **素数** 相乘十分容易，但想要对其乘积进行 **因式分解** 却极其困难，因此可以将 **乘积** 公开作为 **加密密钥**。

- **ECC算法**

  `ECC` 也是一种 **非对称加密算法**，主要优势是在某些情况下，它比其他的方法使用 **更小的密钥**，比如 `RSA` **加密算法**，提供 **相当的或更高等级** 的安全级别。不过一个缺点是 **加密和解密操作** 的实现比其他机制 **时间长** (相比 `RSA` 算法，该算法对 `CPU` 消耗严重)。

**各种加密算法对比:**

- 散列算法比较

  | 名称  | 安全性 | 速度 |
  | :---- | :----- | :--- |
  | SHA-1 | 高     | 慢   |
  | MD5   | 中     | 快   |
  
  


- 对称加密算法比较

  | 名称 | 密钥名称        | 运行速度 | 安全性 | 资源消耗 |
  | :--- | :-------------- | :------- | :----- | :------- |
  | DES  | 56位            | 较快     | 低     | 中       |
  | 3DES | 112位或168位    | 慢       | 中     | 高       |
  | AES  | 128、192、256位 | 快       | 高     | 低       |

  

- 非对称加密算法比较

  | 名称 | 成熟度 | 安全性 | 运算速度 | 资源消耗 |
  | :--- | :----- | :----- | :------- | :------- |
  | RSA  | 高     | 高     | 中       | 中       |
  | ECC  | 高     | 高     | 慢       | 高       |



### 【HTTPS为什么要用对称加密+非对称加密，相对于只使用非对称加密有什么好处】

非对称加密算法用于在握手过程中加密生成的密码，对称加密算法用于对真正传输的数据进行加密，而HASH算法用于验证数据的完整性。

**原因：**

而非对称加密算法运行速度以及资源消耗都高于对称加密，所以使用两种方法结合起来效果更好。



### 【HTTPS加密在哪一层实现】

SSL协议位于TCP/IP协议与各种应用层协议之间，即SSL记录协议和握手协议分别处理会话层和表示层



### 【HTTPS中间人攻击问题】

**概念：**

> **中间人攻击**（英语：**M**an-**i**n-**t**he-**m**iddle attack，缩写：**MITM**）在[密码学](https://zh.wikipedia.org/wiki/密码学)和[计算机安全](https://zh.wikipedia.org/wiki/计算机安全)领域中是指攻击者与通讯的两端分别建立独立的联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方直接对话，但事实上整个会话都被攻击者完全控制。在中间人攻击中，攻击者可以拦截通讯双方的通话并插入新的内容。在许多情况下这是很简单的（例如，在一个未加密的[Wi-Fi](https://zh.wikipedia.org/wiki/Wi-Fi) [无线接入点](https://zh.wikipedia.org/wiki/无线接入点)的接受范围内的中间人攻击者，可以将自己作为一个中间人插入这个网络）。
>
> 一个中间人攻击能成功的前提条件是攻击者能将自己伪装成每一个参与会话的终端，并且不被其他终端识破。中间人攻击是一个（缺乏）相互[认证](https://zh.wikipedia.org/wiki/认证)的攻击。大多数的加密协议都专门加入了一些特殊的认证方法以阻止中间人攻击。例如，[SSL](https://zh.wikipedia.org/wiki/SSL)协议可以验证参与通讯的一方或双方使用的证书是否是由权威的受信任的[数字证书认证机构](https://zh.wikipedia.org/wiki/数字证书认证机构)颁发，并且能执行双向身份认证。                                                                     ——[维基百科](https://zh.wikipedia.org/zh-hans/%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB)

简单来说攻击者就是一个介入通信的传话员，攻击者知道通信双方的所有通信内容，而且可以任意增加、删除、修改双方的通信内容，而双方对此并不知情。



**一个通俗的例子：**

1. 假设 Tom 想和 Jerry 交换一些秘密信息，然而 Tom 又不想跑到 Jerry 家里，于是 Tom 叫来了邮递员，给了邮递员一封信。信的内容是希望 Jerry 给 Tom 一个盒子（这个盒子有两把钥匙）和其中一把钥匙（另一把在 Jerry 手里）。
2. 邮递员在拿到 Tom 给的信件以后，把 Tom 的信拆开看了一遍，了解到 Tom 希望 Jerry 给 Tom 一个有锁的盒子，又用另一个信封装了回去，并交给了 Jerry。
3. Jerry 在收到 Tom 的信（实际已经被邮递员拆阅过了）之后，给了邮递员一个有锁的盒子和其中一把钥匙。
4. 邮递员想知道他们的通信内容，于是他把 Jerry 给 Tom 的盒子换成了他自己的盒子，并附上了自己盒子中的一把钥匙，并在之后将自己的盒子交给了 Tom。
5. Tom 在收到盒子之后，以为这个盒子是 Jerry 给他的，于是就把秘密的信件放进了盒子里，并把钥匙留下了，之后又交给了邮递员。
6. 邮递员在拿到盒子之后，用自己的另一把钥匙打开盒子，看了里面的信件。之后将信件调换之后放进了 Jerry 给的盒子，交给了 Jerry。
7. Jerry 在拿到邮递员给他的盒子之后，并不知道这个盒子里的信件其实已经被邮递员调换过了，所以 Jerry 认为盒子里的信件是来自 Tom 且未被修改过的。之后 Jerry 把回信放进了盒子里，又交给了邮递员。
8. 邮递员再次调换盒子里的信件，交给了 Tom。

这就是一个典型中间人攻击的过程。在 HTTPS 中，Tom 就是客户端，Jerry 是服务端，而邮递员就是客户端和服务端之间的任何实体（包括代理服务器、路由器、反向代理服务器等等），两把钥匙分别是公钥和私钥。通信双方并不知道（且通常很难发觉）自己其实在和*中间人*通信而非直接和对方通信。在通信过程中，Tom 和 Jerry 并没有验证对方的身份，这就导致了邮递员可以任意查看、修改或者丢弃双方的通信内容。



[**如何进行中间人攻击：**](https://elliotsomething.github.io/2016/12/22/HTTPS%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB%E5%8F%8A%E9%98%B2%E5%BE%A1/)

- 攻击一：**SSLSniff**

  攻击者在网关截获SSL会话，替换服务器公钥证书，将公钥`PKey`换成自己的公钥`PKey`，欺骗客户端。客户端使用`PKey`加密信息并发送会话，中间人用私钥`Skey`解密客户端返回会话，从而劫持会话。同时，中间人用`PKey`加密明文会话并返回服务器

- 攻击二：**SSLStrip**

  这种攻击相对于攻击一复杂一点，但是也更加厉害，几乎可以在客户端无感知的情况下实施攻击，并且不需要伪造证书；简单来说就是这样：`Attacker`在客户端与服务器建立连接时，在`Attacker`与服务器之间形成HTTPS连接，而在客户端与`Attacker`之间形成`HTTP`连接，即将SSL层从原HTTPS连接中“剥离”。这样，既避免了在客户端验证证书时难以避免的弹框问题，又能够劫持HTTP明文数据，并同时保证客户端`HTTP`数据的传输，达到欺骗服务器与客户端的效果。



**HTTPS 如何防范中间人攻击:**

通信过程的安全性**自下而上**就是这样保证的：

1. 双方通信内容的安全性是靠公钥加密、私钥解密来保证的，这一安全性由非对称加密的特性，即由公钥加密的信息只能使用对应的私钥才能解开来保证。由于私钥不会传递，只有拥有者知道，所以安全性就由**公钥**的正确性来保证。
2. 公钥由对方在通信初始所提供，但是这时很容易被中间人替换掉，为了保证公钥的正确性，所以在发送公钥的时候也会提供对应的数字证书，用于验证这个公钥是对方的而不是中间人的。那么安全性就是由**数字证书**的正确性来保证了。
3. 数字证书是由上级 CA 签发给个人 / 组织的，上级 CA 用自己的私钥给个人证书进行签名，保证证书中的公钥不被篡改，而接受者需要用上级 CA 证书中的公钥来解密个人数字证书中的数字签名来验证证书中的公钥是否是正确的。那么安全性就是由**上级 CA 证书**的正确性保证的了。*
4. 但是，上级 CA 证书也是由其上级 CA 签发的，这种信任关系一直到根证书。根证书没有上级 CA 为其签名，而是自签名的，也就是说，它自身为自身签名，保证正确性。所以根证书就是这个信任链最重要的部分。如果根证书泄露的话，其签名的所有证书及使用其签名的证书所签名的证书的安全性将不复存在。现在，安全性就是靠系统**根证书**的私钥不被泄露或者其公钥不被篡改来保证的了。
5. 根证书不应该通过网络分发，因为通过网络分发的话，可能会被中间人攻击。一般根证书都通过操作系统或者浏览器分发，在操作系统中会内置很多根证书，但是最初的操作系统也不能通过网络分发，因为中间人可以修改操作系统中的根证书。所以要保证安全只能靠最原始的方法，当面交流。硬件厂商会和证书签发机构合作，在电脑、手机等设备出厂的时候在其操作系统中**内置**签发机构的根证书，再将这些设备分发出去，这样，这些设备的用户就可以安全地进行信息交换了。所以，安全性就依赖于这些设备在分发到消费者手中之前不会被恶意修改来保证了。

至此，整个信任链就建立起来了，只需要有一台设备上安装了可以信任的根证书，就可以用来分发更多安全的操作系统了。之后的所有信任链都是安全的了。



### 【TLS/SSL】  

**概念：**

- SSL：(Secure Socket Layer，安全套接字层），位于可靠的面向连接的网络层协议和应用层协议之间的一种协议层。SSL通过互相认证、使用数字签名确保完整性、使用加密确保私密性，以实现客户端和服务器之间的安全通讯。该协议由两层组成：SSL记录协议和SSL握手协议。
- TLS：(Transport LayerSecurity，传输层安全协议)，用于两个应用程序之间提供保密性和数据完整性。该协议由两层组成：TLS记录协议和TLS握手协议。



**关系：**

最新版本的TLS（Transport LayerSecurity，传输层安全协议）是IETF（Internet Engineering Task Force，Internet工程任务组）制定的一种新的协议，它建立在SSL 3.0协议规范之上，是SSL 3.0的后续版本。在TLS与SSL3.0之间存在着显著的差别，主要是它们所支持的**加密算法**不同，所以TLS与SSL3.0不能互操作。

-  **TLS与SSL的差异**

   1. 版本号：TLS记录格式与SSL记录格式相同，但版本号的值不同，TLS的版本1.0使用的版本号为SSLv3.1。
2. 报文鉴别码：SSLv3.0和TLS的MAC算法及MAC计算的范围不同。TLS使用了RFC-2104定义的HMAC算法。SSLv3.0使用了相似的算法，两者差别在于SSLv3.0中，填充字节与密钥之间采用的是连接运算，而HMAC算法采用的是异或运算。但是两者的安全程度是相同的。
   3. 伪随机函数：TLS使用了称为PRF的伪随机函数来将密钥扩展成数据块，是更安全的方式。
4. 报警代码：TLS支持几乎所有的SSLv3.0报警代码，而且TLS还补充定义了很多报警代码，如解密失败（decryption_failed）、记录溢出（record_overflow）、未知CA（unknown_ca）、拒绝访问（access_denied）等。
   5. 密文族和客户证书：SSLv3.0和TLS存在少量差别，即TLS不支持Fortezza密钥交换、加密算法和客户证书。
6. certificate_verify和finished消息：SSLv3.0和TLS在用certificate_verify和finished消息计算MD5和SHA-1散列码时，计算的输入有少许差别，但安全性相当。
   7. 加密计算：TLS与SSLv3.0在计算主密值（master secret）时采用的方式不同。
8. 填充：用户数据加密之前需要增加的填充字节。在SSL中，填充后的数据长度要达到密文块长度的最小整数倍。而在TLS中，填充后的数据长度可以是密文块长度的任意整数倍（但填充的最大长度为255字节），这种方式可以防止基于对报文长度进行分析的攻击。
   

   
- **TLS的主要增强内容**

   TLS的主要目标是使SSL更安全，并使协议的规范更精确和完善。TLS 在SSL v3.0 的基础上，提供了以下增强内容：

   1. 更安全的MAC算法
2. 更严密的警报
   3. “灰色区域”规范的更明确的定义

   

- **TLS对于安全性的改进**

   1. 对于消息认证使用密钥散列法：TLS 使用“消息认证代码的密钥散列法”（HMAC），当记录在开放的网络（如因特网）上传送时，该代码确保记录不会被变更。SSLv3.0还提供键控消息认证，但HMAC比SSLv3.0使用的（消息认证代码）MAC 功能更安全。

   2. 增强的伪随机功能（PRF）：PRF生成密钥数据。在TLS中，HMAC定义PRF。PRF使用两种散列算法保证其安全性。如果任一算法暴露了，只要第二种算法未暴露，则数据仍然是安全的。

   3. 改进的已完成消息验证：TLS和SSLv3.0都对两个端点提供已完成的消息，该消息认证交换的消息没有被变更。然而，TLS将此已完成消息基于PRF和HMAC值之上，这也比SSLv3.0更安全。

   4. 一致证书处理：与SSLv3.0不同，TLS试图指定必须在TLS之间实现交换的证书类型。

   5. 特定警报消息：TLS提供更多的特定和附加警报，以指示任一会话端点检测到的问题。TLS还对何时应该发送某些警报进行记录。

