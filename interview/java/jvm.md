---
title: JVM
permalink: /interview/java/jvm
key: jvm
---

## start

### 【1.7和1.8的JVM有哪些不同】

1.8版本用**元数据区**取代了1.7版本及以前的**永久代**。元数据区和永久代本质上都是方法区的实现。

元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存(也就是说Jvm可以使用外边的内存)。因此，默认情况下，元空间的大小仅受本地内存限制，但可以通过以下参数来指定元空间的大小




## **内存区域**

### 【虚拟内存】

[概念](https://baike.baidu.com/item/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/101812?fr=aladdin)

​	虚拟内存是计算机系统**内存管理**的一种技术。它使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行**数据交换**。目前，大多数操作系统都使用了虚拟内存，如Windows家族的“虚拟内存”；Linux的“交换空间”等

比如windows电脑，打开任务管理器，进入性能选项，然后点击内存，可以查看内存使用情况，可以看到其已提交的内存容量是大于实际物理内存条容量的



### 【如果访问虚拟地址时，该地址在物理内存中不存在，会发生什么】

​	盲猜无法访问



### 【Jvm内存模型】   

参考文章：https://www.nowcoder.com/discuss/151138?type=1

​	![JVM内存划分](http://image.yangyhao.top/blog/JVM-%E5%86%85%E5%AD%98%E5%88%92%E5%88%86.png)

- **程序计数器**

  **作用**：

  字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理

  在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。

  **特点：**

  线程私有，唯一一个不会出现OOM的内存区域

- **Java虚拟机栈**

- **本地方法栈**

- **方法区**

- **堆**



### 【结合内存模型，java为什么可以跨平台】

​	因为Java不是运行在CPU上的，它是运行在JVM上面的，Java程序编译成字节码文件以后可以由JVM去“翻译”成对应平台硬件能执行的代码；

​	同时JVM在不同的操作系统，windows、linux、mac等都有支持，相当于JVM进行了适配，做到了JVM跨平台，所以开发人员只需要遵循Java语法就能在不同的平台上运行



### 【堆的原理和分代】   

​	JVM根据对象在内存中**存活时间**的长短，把堆内存分为**新生代**（包括一个Eden区、两个Survivor区）和**老年代**（Tenured或Old）。Perm代（**永久代**，Java 8开始被“**元空间**”取代）属于方法区了，而且仅在Full GC时被回收



### 【哪些是线程共有的，和私有的】

​	堆是线程共有的、栈是线程私有的



### 【Jvm内存中什么地方会发生OOM】  

​	除了程序计数器没有规定OOM外，其他任何内存区域都会发生OOM



### 【运行时常量池】 

**概念**
	运行时常量池是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息时常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。

​	运行时常量池相对于Class文件常量池的另外一个重要特征是具备**动态性**，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用比较多的就是String类的intern()方法。

​	final 常量 static 静态变量都是存放在运行时常量池中的

**好处**
	常量池是为了避免频繁的创建和销毁对象而影响系统性能，其实现了对象的共享。

**位置**

​	Jdk1.6 常量池在方法区 1.7在堆 1.8变元空间



### 【Java中如何实现共享内存】

​	对UNIX系统来说，共享内存分为一般共享内存和映像文件共享内存两种，对windows实际上只有映像文件共享内存一种。所以java应用中也是只能**创建映像文件共享内存**。

​	在jdk1.4中提供的类`MappedByteBuffer`为我们提供了实现共享内存的方法，该缓冲区实际上是一个磁盘文件的内存映像。



### 【Java内存泄漏如何排查】

**概念**：

内存泄漏是指程序在申请内存后，无法释放已申请的内存空间

**原因：**

内存泄漏的原因分析，总结出来只有一条：**存在无效的引用！**

**排查**：

1. 识别症状

   正如所讨论的，在许多情况下，Java进程最终会抛出一个OOM运行时异常，这是一个明确的指示，表明您的内存资源已经耗尽。在这种情况下，您需要区分正常的内存耗尽和泄漏。分析OOM的消息并尝试根据上面提供的讨论找到罪魁祸首。

   通常，如果Java应用程序请求的存储空间超过运行时堆提供的存储空间，则可能是由于设计不佳导致的。例如，如果应用程序创建映像的多个副本或将文件加载到数组中，则当映像或文件非常大时，它将耗尽存储空间。这是正常的资源耗尽。该应用程序按设计工作（虽然这种设计显然是愚蠢的）。

   但是，如果应用程序在处理相同类型的数据时稳定地增加其内存利用率，则可能会发生内存泄漏。

2. 启用详细垃圾回收

   通常可以通过检查verbosegc输出中的模式来识别内存约束问题。

3. 启用分析

   不同的JVM提供了生成跟踪文件以反映堆活动的不同方法，这些方法通常包括有关对象类型和大小的详细信息。这称为分析堆。

4. 分析踪迹



## **垃圾回收**

硬软弱虚引用，以及软引用的回收时机  
JVM的垃圾回收机制  
如何触发full gc，用jvm命令如何触发  
fullgc是否可以回收方法区   
fullgc的时候会导致接口的响应速度特别慢，如何排查和解决  
频繁full gc怎么办  
说说GC的过程  
强制young gc会有什么问题？  
怎么避免产生浮动垃圾？  
回收那些对象，需要怎么分辨  
为什么要进行分代回收？  



**垃圾回收算法**

gc算法，怎么判断对象可被回收  
新生代和年老代的GC算法分别是什么  
标记清除和标记整理的区别  
1.8的垃圾回收算法，介绍你所知道的垃圾回收算法  
常见的垃圾回收算法。  
标记清除和标记整理的区别。  
老年代用别的回收算法行不行  
jvm中哪些可以作为垃圾回收的gcroot?为什么呢？  
你提到的Remember Set底层是怎么实现的？  



**垃圾回收器**

知道G1么？  回收过程是怎么样的？  
了解过CMS收集器吗？CMS GC有什么问题？   
cms会STW吗？   
各种垃圾收集器、GC算法，安全点   
垃圾回收器简要介绍，讲一个单线程和一个多线程的。   
jdk1.8用的是哪个垃圾回收器？  
CMS的回收过程，G1的回收过程，两者的比较  




## **类加载**

类加载机制  
类的编译过程  
类的加载过程   
class文件在1.8存储在哪  
如何实现自己的classloader  
如何动态加载类  
类加载机制，不同加载器之间的关系。  
什么时候需要自定义类加载器？  
说一下java类加载器的工作机制？类加载在那个区域进行的？  
什么是双亲委派机制？为什么要有双亲委派机制？双亲委派机制是怎样实现的  ？  
你自己定义的类能被最顶级的类加载器加载吗？为什么？  
自定义的类会被什么类加载器加载？  
如何加载一个不在根目录下的类  
新建一个对象的流程。（从类加载开始讲）  



## **分析调优** 

### 【Jvm如何支持编解码】 

JVM参数可以设置字符编码	`-Dfile.encoding=utf-8` 

如何分析OOM发生的原因？  
让你自己实现OOM，你会怎么做？  
高并发环境如何避免OOM。  
有过GC调优的经历么  
JVM与GC，如果大访问量，哪部分可能会OOM，如何处理  
JVM参数调优  
说一说JVM调优的思路及你是怎么样调优的  
数据如果出现了阻塞，你是怎么排查的，top和jstack命令用过没，jstack命令的nid是什么意思，怎么查看java某个进程的线程   
JVM相关的分析工具有使用过哪些？具体的性能调优步骤吗？ 