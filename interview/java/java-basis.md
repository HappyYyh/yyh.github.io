---
title: Java基础
permalink: /interview/java/java-basis
key: java-basis
---

## **面向对象特性**

### **【函数式编程和面向对象编程的区别】**  

面向对象编程是封装，继承，多态，代码重用。

面向函数式编程是数据不可变，惰性求值



### **【面向对象的原则】**  

- 单一职责原则
- 开-闭原则
- 里氏替换原则
- 依赖倒置原则
- 接口隔离原则
- 迪米特法则



### **【面向对象的特性】**  

封装、继承、多态



### 【讲讲你所理解的Java面向对象】

Java是面向对象语言，面向对象特性封装、继承、多态，所以在我看来Java是一种抽象的编程思维，

可以把问题抽象成对象（Object），然后处理问题



### **【Java和c++区别】**  

1、C++创建对象之后，需要再使用完将其调用delete方法将其销毁；而java自动回收垃圾

2、作用域

3、C++有goto关键字，而Java作为保留字段

4、C++多继承，而Java只能单继承

5、C++有指针，而Java没有






## **JDK相关**

### **【JDK1.8为什么要引入函数式编程】**

函数式接口在Java中是指：有且仅有一个抽象方法的接口。

Java中的函数式编程体现就是Lambda



### **【JDK1.8的新特性】**  

- Lambda表达式

- 函数式接口

- 方法引用和构造器调用

- Stream API

- 接口中的默认方法和静态方法

- 新时间日期API

  

### **【JDK1.8和之前版本的不同】**  

同上



## **接口和类**

### **【Java的多态】**  

多态性的解释：子类对象的多态性，父类的引用指向子类对象

Java的多态分为运行时多态和编译时多态。

**编译时多态**：主要是指方法的重载，它是根据参数列表的不同来区分不同的方法。通过编译之后会变成两个不同的方法，在运行时谈不上多态。

**运行时多态**:它是通过动态绑定来实现的，也就是大家通常所说的多态性

即子类可以定义由父类创建，父类的引用指向子类对象

~~~java
List<T> list = new ArraryList<>(); 
~~~



### 【抽象类和接口你倾向用哪个？什么场景下用抽象类】  

1、更加倾向于使用接口；

2、这里要知道抽象类里不仅仅有抽象方法还有普通方法；可以看spring里面的一些源码



### 【类的关系，组合和聚合的区别、哪个关系更紧密】  

依赖(Dependency)关系是类与类之间的联接，**依赖关系在Java语言中体现为局部变量、方法的形参，或者对静态方法的调用。**

~~~java
class Car {  
    public static void run(){  
        System.out.println("汽车在奔跑");  
    }  
}  
   
class Driver {  
    //使用形参方式发生依赖关系  
    public void drive1(Car car){  
        car.run();  
    }  
    //使用局部变量发生依赖关系  
    public void drive2(){  
        Car car = new Car();  
        car.run();  
    }  
    //使用静态变量发生依赖关系  
    public void drive3(){  
        Car.run();  
    }  
}
~~~



关联(Association）关系是类与类之间的联接，**在Java语言中，关联关系一般使用成员变量来实现。**

~~~java
class Driver {  
    //使用成员变量形式实现关联  
    Car mycar;  
    public void drive(){  
        mycar.run();  
    }  
    ...  
    //使用方法参数形式实现关联  
    public void drive(Car car){  
        car.run();  
    }  
}
~~~



聚合(Aggregation) 关系是**关联**关系的一种，是**强的关联关系**

~~~java
class Driver {  
    //使用成员变量形式实现聚合关系  
    Car mycar;  
    public void drive(){  
        mycar.run();  
    }  
}
~~~



组合(Composition) 关系是**关联关系的一种，是比聚合关系强的关系**

~~~java
//为了表示组合关系，常常会使用构造方法来达到初始化的目的
public Driver(Car car){  
    mycar = car;  
}
~~~

**总结**

一般来说依赖、关联、聚合、组合四中关系中，类的关系是依次增强的




## **数据类型**

### 【static修饰用法和区别】

static是java的关键字，可以用来修饰属性、类、方法

**一、static修饰属性**
1.属性随着类的加载而加载，是类变量,其加载早于对象,不需要new即可加载

2.类变量所在的类的所有对象共用这一个属性,存放在静态域中

**二、static修饰方法**
1.方法随着类的加载而加载随着类的加载而加载，是类方法，其加载早于对象,不需要new

2.类方法所在的类的所有对象共用这一个方法.

3.类方法内部只可调用静态的属性和静态的方法，而不能调用非静态的属性和方法
反之，非静态方法可以调用静态的属性和方法

**三、static修饰内部类**
1普通类是不允许声明为静态的，只有内部类才可以

2被static修饰的内部类可以直接作为一个普通类来使用，而不需实例一个外部类



### 【Java基本类型有多少种】  

|  类型   |        精度范围         | 占位 |
| :-----: | :---------------------: | :--: |
|  byte   |        -128 ~127        |  8   |
|  short  |     -32768 ~ 32767      |  16  |
|   int   |    -2^31 ~ 2^31 - 1     |  32  |
|  long   |     -2^63 ~ 2^63 -1     |  64  |
|  float  |  -3.40E+38 ~ +3.40E+38  |  32  |
| double  | -1.79E+308 ~ +1.79E+308 |  64  |
| boolean |       true/false        |  8   |
|  char   |      Unicode 字符       |  16  |



### 【Java中，char型变量能不能存储一个汉字】  

char型变量是用来存储Unicode编码的字符的，unicode编码字符集中包含了汉字

补充：使用Unicode意味着字符在JVM内部和外部有不同的表现形式，在JVM内部都是Unicode，当这个字符被从JVM内部转移到外部时（例如存入文件系统中），需要进行编码转换。



### 【谈谈对BigDecimal的理解】   

一般用于货币计算

https://blog.csdn.net/qq_34530405/article/details/85718774



### 【说说对包装类的理解】  

Java5出现的概念，是对八大基本数据类型的封装

| 基本类型 | 包装类型  |
| :------: | :-------: |
|   byte   |   Byte    |
|  short   |   Short   |
|   int    |  Integer  |
|   long   |   Long    |
|  float   |   Float   |
|  double  |  Double   |
| boolean  |  Boolean  |
|   char   | Character |

1、可以通过包装类于基本数据类型进行自动拆装箱

2、包装类的初始值为null，不同于基本类型

3、泛型无法使用包装类型



### 【java 泛型理解】  

**一、概述**

Java泛型（`generics`）是JDK 5中引入的一个新特性，**泛型提供了编译时类型安全监测机制**，该机制允许程序员在编译时监测非法的类型。使用泛型机制编写的程序代码要比那些杂乱地使用`Object`变量，然后再进行强制类型转换的代码具有**更好的安全性和可读性**。泛型对于集合类尤其有用，例如，`ArrayList`就是一个无处不在的集合类。

**泛型的本质是参数化类型**，也就是所操作的数据类型被指定为一个参数。

**二、泛型的使用**

泛型有三种常用的使用方式：**泛型类**，**泛型接口**和**泛型方法**。





## **String相关**

### 【String是否可以被继承及相关原因】

`String.class`是final修饰的，无法被继承



### 【String为什么要是final类型的;为什么String是不可变的】

主要是为了”安全性“和”效率“的缘故

1、因为**只有当字符串是不可变的，字符串池才有可能实现**。字符串池的实现可以在运行时节约很多heap空间，因为不同的字符串变量都指向池中的同一个字符串。但如果字符串是可变的，那么String interning将不能实现，因为这样的话，如果变量改变了它的值，那么其它指向这个值的变量的值也会一起改变

------

 2、如果字符串是可变的，那么会引起很严重的安全问题。譬如，数据库的用户名、密码都是以字符串的形式传入来获得数据库的连接，或者在socket编程中，主机名和端口都是以字符串的形式传入。因为字符串是不可变的，所以它的值是不可改变的，否则黑客们可以钻到空子，改变字符串指向的对象的值，造成安全漏洞。

------

3、 因为字符串是不可变的，所以**是多线程安全的**，同一个字符串实例可以被多个线程共享。这样便不用因为线程安全问题而使用同步。字符串自己便是线程安全的。

------

4、  因为字符串是不可变的，所以在它创建的时候**HashCode**就被缓存了，不需要重新计算。这就使得字符串很适合作为Map中的键，字符串的处理速度要快过其它的键对象。这就是HashMap中的键往往都使用字符串。





### 【String是不是java的基本类型】

不是



### 【StringBuilder 为什么比String快】

因为String是不可变的，所以在大量拼接等操作字符串需要创建很多个对象，而StringBuilder的操作是同一个对象（字符数组扩容）



### 【String，StringBuffer，StringBuilder的区别】   

**String** : 里面所有的属性几乎也是final,由于它的不可变性，类似拼接，裁剪字符串等动作都会产生大量无用的中间对象。由于字符串操作在项目中很常见，所以对String的操作对项目的性能往往有很明显的影响。

**StringBuffer** : 这个类是为了解决String拼接产生多余对象的问题而提供的一个类。StringBuffer保证了线程的安全，也带来了多余的开销。

**StringBuilder** : StringBuilder的功能与StringBuffer一样。但是区别是StringBuilder没有处理线程安全，减少了开销。




## **异常**

### 【Exception 与 Error】

在java中程序的运行往往会因为设计或者编写过程中引起一些错误的操作，这些错误信息主要包含两种类型

**错误(Error)**：通常是JVM内部错误，或者资源耗尽等一些无法从本质上解决的问题(严重问题)

**异常(Exception)**:因为一些编程错误或者外在因素引起的可以被修复的问题

Error和Exception都是从Throwable类继承过来



### 【异常分类】

1、运行时异常（RuntimeException）:在程序运行时才会出现

- java.lang.NullPointerException<空指针异常>

- java.lang.IndexOutOfBoundsException< 索引超出范围>

- java.lang.ArrayIndexOutOfBoundsException<数组索引越界>

- java.lang.NumberFormatException<转换为数值类型异常>
- java.lang.ClassCastException <类型转换异常>

- java.lang.ArithmeticException <算数异常>




2、一般异常(检查异常)：在编译期就显式的通知程序员必须处理

- java.lang.ClassNotFoundException<类未找到异常>

- java.io.IOException<IO异常>




### 【什么时候throws】


 java程序在运行时或者编译时如果出现异常，则会产生异常对象，对于该异常对象的处理方法，通常包含两种解决方法：

1. 异常抛出（throws）
2. 异常捕获（try...catch...fianlly）


  


## **注解的使用**

注解处理器  

怎么实现自定注解  




## **反射**

说一下反射，及你在项目中的应用   
了解浅拷贝和深拷贝的区别吗  
引用（四个强度之类的）  
string example=“一个网址”，求一个example的实例  
反射讲一下，写一个反射的例子   
反射机制的底层实现是什么  


## **其他**

==和equals区别？  
重写hashcode()是否需要重写equals()，不重写会有什么后果 ？  
不加任何修饰符的java最像哪个访问修饰符   
序列化和实现方式，作用？  